#!/usr/bin/env bash
# Sets the string to use a replace target
VER='VERSION'

# String used to signal a prerelease
PRERELEASE_STRING='rc'

# Provide a list of files to modify and the regex to use for them
# in the form of FILE;REGEX
# use $VER
FILES=(
  # 'package.json;"version": "VERSION"'
)

# Regex used to parse semver
# \1 = MAJOR
# \2 = MINOR
# \3 = PATCH
# \5 = PRERE
# \8 = BUILD
SEMVER='(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.0|\.[1-9]\d*|\.\d*[a-zA-Z-][0-9a-zA-Z-]*)*)?(\+([0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*))?'

help() {
  echo "bash2version - bash your version number into place

bash2version --set VERSION | --bump major|minor|patch|prerelease [--build BUILD] [FILES]

OPTIONS:
  -b, --bump major|minor|patch|prerelease:
      bumps the specified version segment, prerelease either adds 
      or removes the prerelease segment ('-rc' by default)

  --build BUILD:
      add build metadata specified by BUILD

  -s, --set VERSION:
      set the version to the string provided by VERSION

  FILES:
      the files and regex to run on in the format file;regex VERSION
      Use VERSION as a placeholder for where the version would be"
}

# Check if an argument was provided to the given option;
check_arg_exist() {
    if [[ -z $2 || $2 == "-"* ]]; then
        echo "ERROR: argument $1 requires an argument!"
        exit 1
    fi
}


POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -b | --bump)
      check_arg_exist "$1" "$2"
      BUMP=$2
      shift
      shift
    ;;
    --build)
      check_arg_exist "$1" "$2"
      BUILD=$2
      shift
      shift
    ;;
    -s | --set)
      check_arg_exist "$1" "$2"
      SETVERSION=$2
      shift
      shift
    ;;
    --help)
      help
      exit
      shift
    ;;
    *)
      POSITIONAL+=("$1")
      shift
    ;;
  esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters

get_version() {
  if [ ! -n "${FILES[0]}" ]; then
    echo "No Files provided. Exiting..."
    exit
  fi
  MATCH=${FILES[0]#*;}
  TMPVERSION=$(sed -nr "s/.*${MATCH/VERSION/$SEMVER}.*/\1;\2;\3;\5;\8/gp" ${FILES[0]%;*})
  IFS=';' read -r MAJOR MINOR PATCH PRERE BUILDT <<< "$TMPVERSION"; IFS=''
}

set_version() {
  if [ ! -z $SETVERSION ]; then
    VERSION=$SETVERSION$(if [ ! -z $BUILD ]; then echo "+$BUILD"; fi)
  elif [ ! -z $BUMP ]; then
    if [ "${BUMP,,}" == "major" ]; then
      VERSION=$((MAJOR + 1)).0.0$(if [ ! -z $PRERE ]; then echo -$PRERE; fi)$(if [ ! -z $BUILD ]; then echo +$BUILD; fi)
    elif [ "${BUMP,,}" == "minor" ]; then
      VERSION=$MAJOR.$((MINOR + 1)).0$(if [ ! -z $PRERE ]; then echo -$PRERE; fi)$(if [ ! -z $BUILD ]; then echo +$BUILD; fi)
    elif [ "${BUMP,,}" == "patch" ]; then
      VERSION=$MAJOR.$MINOR.$((PATCH + 1))$(if [ ! -z $PRERE ]; then echo -$PRERE; fi)$(if [ ! -z $BUILD ]; then echo +$BUILD; fi)
    elif [ "${BUMP,,}" == "prerelease" ]; then
      VERSION=$MAJOR.$MINOR.$PATCH$(if [ -z $PRERE ]; then echo "-$PRERELEASE_STRING"; fi)$(if [ ! -z $BUILD ]; then echo "+$BUILD"; fi)
    else
      echo "No valid Version segment provided"
      exit 1
    fi
  fi
}

apply_version() {
  OLDIFS=$IFS
  IFS=';'

  echo "Applying Version: $VERSION"

  for i in "${FILES[@]}"; do
    set -- $i
    sed -ri "s/${2/VERSION/$SEMVER}/${2/VERSION/$VERSION}/g" $1
  done

  IFS=''
}

if [[ -z $SETVERSION && -z $BUMP ]]; then
  help
  exit
else
  if [ -n "$@" ]; then
    FILES=( "$@" )
  fi
  get_version
  set_version
  apply_version
fi

